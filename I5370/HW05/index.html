<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=yes"/>
    <style type="text/css">@import"index.css";</style>
    <title>GI112 • HW05</title>
    <link rel="Shortcut Icon" type="image/x-icon" href="../icon.ico"/>
</head>

<body> 
            
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/88/three.min.js"></script>
<!--<script src="./three.js-master/examples/js/loaders/OBJLoader.js"></script>-->
<!--<script src="./three.js-master/examples/js/loaders/MTLLoader.js"></script>-->
<script src="https://rawgit.com/mrdoob/three.js/master/examples/js/loaders/MTLLoader.js"></script>
<script src="https://rawgit.com/mrdoob/three.js/master/examples/js/loaders/OBJLoader.js"></script>

<script src="https://threejs.org/examples/js/controls/OrbitControls.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/stats.js/r16/Stats.min.js"></script>
<script src="https://code.jquery.com/jquery-2.1.4.min.js"></script>

<script src="https://jyunming-chen.github.io/tutsplus/js/KeyboardState.js"></script>

<script>
    // renderer : 渲染器，負責計算在 camera 的角度下，browser 中 scene 的樣子。
    // scene : 場景，我們所看到的畫面。
    // camera : 定義了使用者能在渲染好的 scene 看到什麼，也就是使用者的視角。
    var renderer, camera, controls, scene, axes;
    var keyboard = new KeyboardState();
    var clock;
    
    var chair;
    var pos = new THREE.Vector3();
    var speed, angle, vel;
    (function() {
        Math.clamp = function(val,min,max){
        return Math.min(Math.max(val,min),max);
    }})();
    init();  // 創建渲染器
    animate();

    function buildDeskParts() {
        var parts = [];
        
        //var mat = new THREE.MeshNormalMaterial()
    	var mat = new THREE.MeshLambertMaterial({color:0x408080});

        // 桌面
        var desk = new THREE.Object3D();
        var deskMesh = new THREE.Mesh (new THREE.BoxGeometry (40, 80, 2),mat);  // 桌面

        deskMesh.rotation.x = Math.PI/2;
        deskMesh.position.y = 40;

        desk.add (deskMesh);
        parts.push (desk);

        // 桌腳 (共 4 支)
        var legs = new THREE.Object3D();
        var legsMesh_1 = new THREE.Mesh (new THREE.BoxGeometry (5, 5, 40),mat);  // 桌腳_1
        var legsMesh_2 = new THREE.Mesh (new THREE.BoxGeometry (5, 5, 40),mat);  // 桌腳_2
        var legsMesh_3 = new THREE.Mesh (new THREE.BoxGeometry (5, 5, 40),mat);  // 桌腳_3
        var legsMesh_4 = new THREE.Mesh (new THREE.BoxGeometry (5, 5, 40),mat);  // 桌腳_4

        legsMesh_1.rotation.x = Math.PI/2;
        legsMesh_1.position.x = -10;
        legsMesh_1.position.y = 20;
        legsMesh_1.position.z = 20;

        legsMesh_2.rotation.x = Math.PI/2;
        legsMesh_2.position.x = -10;
        legsMesh_2.position.y = 20;
        legsMesh_2.position.z = -20;

        legsMesh_3.rotation.x = Math.PI/2;
        legsMesh_3.position.x = 10;
        legsMesh_3.position.y = 20;
        legsMesh_3.position.z = 20;

        legsMesh_4.rotation.x = Math.PI/2;
        legsMesh_4.position.x = 10;
        legsMesh_4.position.y = 20;
        legsMesh_4.position.z = -20;

        legs.add (legsMesh_1);
        legs.add (legsMesh_2);
        legs.add (legsMesh_3);
        legs.add (legsMesh_4);

        parts.push (legs);

        deskMesh
        deskMesh.castShadow = true;
        deskMesh.receiveShadow = true;
        legsMesh_1.castShadow = true;
        legsMesh_1.receiveShadow = true;
        legsMesh_2.castShadow = true;
        legsMesh_2.receiveShadow = true;
        legsMesh_3.castShadow = true;
        legsMesh_3.receiveShadow = true;
        legsMesh_4.castShadow = true;
        legsMesh_4.receiveShadow = true;

        return parts;
    }

    function buildDesk(){
        
        let parts = buildDeskParts();
        let desk = new THREE.Object3D();

        // 桌子。
        let deskPart = parts[0];
        let legsPart = parts[1];
        desk.add (deskPart);
        desk.add (legsPart);

        return desk;
    }

    function buildControlParts() {
        var parts = [];
        
        //var mat = new THREE.MeshNormalMaterial()
    	var mat = new THREE.MeshLambertMaterial({color:0xFFFFFF});

        // 遙控器
        var control = new THREE.Object3D();
        var controlMesh = new THREE.Mesh (new THREE.BoxGeometry (15, 10, 4),mat);  // 桌面

        controlMesh.rotation.x = Math.PI/2;
        controlMesh.position.y = 43;

        control.add (controlMesh);
        parts.push (control);

        // 按鈕_1 (共 2 個)
        var btns_1 = new THREE.Object3D();
        var btnsMesh_1 = new THREE.Mesh (new THREE.CylinderGeometry (2.5, 2.5, 2.5, 30), mat);  // 按鈕_1

        //btnsMesh.rotation.x = Math.PI/2;
        btnsMesh_1.position.x = 4;
        btnsMesh_1.position.y = 46.5;
        btnsMesh_1.position.z = 0;

        btns_1.add (btnsMesh_1);

        parts.push (btns_1);

        // 按鈕_2 (共 2 個)
        var btns_2 = new THREE.Object3D();
        var btnsMesh_2 = new THREE.Mesh (new THREE.CylinderGeometry (2.5, 2.5, 2.5, 30), mat);  // 按鈕_2

        //btnsMesh.rotation.x = Math.PI/2;
        btnsMesh_2.position.x = -4;
        btnsMesh_2.position.y = 46.5;
        btnsMesh_2.position.z = 0;

        btns_2.add (btnsMesh_2);

        parts.push (btns_2);

        return parts;
    }

    function buildControl(){
        
        let parts = buildControlParts();
        let ctrl = new THREE.Object3D();

        // 遙控器。
        let ctrlPart = parts[0];
        let btnsPart_1 = parts[1];
        let btnsPart_2 = parts[2];
        ctrl.add (ctrlPart);
        ctrl.add (btnsPart_1);
        ctrl.add (btnsPart_2);

        return ctrl;
    }

    function buildChair() {
        var onProgress = function (xhr) {
            if (xhr.lengthComputable) {
                var percentComplete = xhr.loaded / xhr.total * 100;
                console.log(Math.round(percentComplete, 2) + '% downloaded');
            }
        };

        var onError = function (xhr) { };
            
        var mtlLoader = new THREE.MTLLoader();
        mtlLoader.setPath('./chair/');
        mtlLoader.load('WoodChair_01.mtl', function(materials) {
            materials.preload();
            var objLoader = new THREE.OBJLoader();
            objLoader.setMaterials(materials);
            objLoader.setPath('./chair/');
            objLoader.load('WoodChair_01.obj', function(object) {
        
                theObject =  unitize (object, 50);

                theObject.rotation.x = - (Math.PI / 2);
                theObject.position.x = 30;
                theObject.position.y = 25;
                theObject.position.z = 13;
                scene.add (theObject);

                chair = theObject;
            }, onProgress, onError);
        });

    }

    function buildlamp() {
        var onProgress = function (xhr) {
            if (xhr.lengthComputable) {
                var percentComplete = xhr.loaded / xhr.total * 100;
                console.log(Math.round(percentComplete, 2) + '% downloaded');
            }
        };

        var onError = function (xhr) { };
            
        var mtlLoader = new THREE.MTLLoader();
        mtlLoader.setPath('./lamp/');
        mtlLoader.load('Desk lamp.mtl', function(materials) {
            materials.preload();
            var objLoader = new THREE.OBJLoader();
            objLoader.setMaterials(materials);
            objLoader.setPath('./lamp/');
            objLoader.load('Desk lamp.obj', function(object) {
        
                theObject =  unitize (object, 30);

                theObject.position.x = -10;
                theObject.position.y = 41;
                theObject.position.z = 20;
                theObject.rotation.y = 0.8;
                scene.add (theObject);

                //chair = theObject;
            }, onProgress, onError);
        });

    }

    function buildChandelier() {
        var onProgress = function (xhr) {
            if (xhr.lengthComputable) {
                var percentComplete = xhr.loaded / xhr.total * 100;
                console.log(Math.round(percentComplete, 2) + '% downloaded');
            }
        };

        var onError = function (xhr) { };
            
        var mtlLoader = new THREE.MTLLoader();
        mtlLoader.setPath('./Chandelier/');
        mtlLoader.load('Chandelier.mtl', function(materials) {
            materials.preload();
            var objLoader = new THREE.OBJLoader();
            objLoader.setMaterials(materials);
            objLoader.setPath('./Chandelier/');
            objLoader.load('Chandelier.obj', function(object) {
        
                theObject =  unitize (object, 30);

                theObject.position.x = -10;
                theObject.position.y = 41;
                theObject.position.z = 20;
                theObject.rotation.y = 0.8;
                scene.add (theObject);

                //chair = theObject;
            }, onProgress, onError);
        });

    }

    function unitize (object, targetSize) {  
  
        // find bounding box of 'object'
        var box3 = new THREE.Box3();
        box3.setFromObject (object);
        var size = new THREE.Vector3();
        size.subVectors (box3.max, box3.min);
        var center = new THREE.Vector3();
        center.addVectors(box3.max, box3.min).multiplyScalar (0.5);
        
        // uniform scaling according to objSize
        var objSize = Math.max (size.x, size.y, size.z); 
        var scaleSet = targetSize/objSize;
        
        var theObject =  new THREE.Object3D();
        theObject.add (object);
        object.scale.set (scaleSet, scaleSet, scaleSet);
        object.position.set (-center.x*scaleSet, -center.y*scaleSet + size.y/2*scaleSet, -center.z*scaleSet);
        
        return theObject;
    }

    function buildlamplight(){
        var mat = new THREE.MeshBasicMaterial({color:0xFFFFFF, wireframe: true});
        let sunObj = new THREE.Object3D();
        sun = new THREE.Mesh (new THREE.SphereGeometry( 2, 32, 32 ),mat);
        sun.position.set (-7.5, 66, 17);
        sunObj.add (sun);
        return sunObj;
    }

    function buildFloor() {
        // 物件 (地板)
        let floor = new THREE.Object3D();
        // 幾何 (平面)
        let floorGeometry = new THREE.PlaneGeometry( 300, 300, 1, 1 );
        // 材質 (貼圖) (來源: https://pixabay.com/zh/地板-家居-花纹-质地-624772/) (CC0)
        let texture = new THREE.TextureLoader().load('./Mesh/floor.png');
        texture.wrapS = THREE.RepeatWrapping;
        texture.wrapT = THREE.RepeatWrapping;
        texture.repeat = new THREE.Vector2(3, 3);
        // 材質 (Phong)
        let floorMaterial = new THREE.MeshPhongMaterial({ 
            map: texture, 
            side: THREE.DoubleSide
        });
       
        // 物件
        let floorMesh = new THREE.Mesh( floorGeometry, floorMaterial );
        floorMesh.rotation.x = Math.PI / -2;
        floorMesh.position.y = 0;
        // 定義哪個物體接受陰影。
        floorMesh.receiveShadow = true;
        floor.add(floorMesh); 
        scene.add(floor);
    }

    function init() {
        renderer = new THREE.WebGLRenderer({
            antialias: true
        });
        renderer.setSize(window.innerWidth, window.innerHeight - 10);
        renderer.setClearColor(0x84C1FF);  // 設定背景顏色
        camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 1, 1000);
        camera.position.z = 250;  // important
        camera.position.y = 150;
        //camera.position.x = 35;
        controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableKeys = false;
        document.body.appendChild(renderer.domElement);
        clock = new THREE.Clock();
        scene = new THREE.Scene();  // 建立場景
      
        // 設定座標網格。
        // THREE.GridHelper(面積, 長寬長度, xy軸顏色, 網格顏色);
        let gridXZ = new THREE.GridHelper(1000, 10, 'red', 'white');
        
        scene.add(gridXZ);
        let lamplight = buildlamplight();
        let ctrl = buildControl();

        //ctrl.position.y = 10;
        //ctrl.position.z = 10;

        let spotLight = new THREE.SpotLight(0xffffff)
        spotLight.position.set( 0, 120, 0 );
        spotLight.castShadow = true;

        scene.add(spotLight);

        buildFloor();
        buildChair();
        buildChandelier();

        buildlamp();
        
        let desk = buildDesk();
        scene.add (desk);
        scene.add (ctrl);
        scene.add (lamplight);

        // 添加光源
        //scene.add(new THREE.AmbientLight(0x444444));  // 環境光

        let light = new THREE.SpotLight(0xffffff);  // 點光源
        light.position.set( -7.5, 66, 17 );
        light.castShadow = true;  // 告訴平行光需要開啟陰影投射

        //light.distance = 50; 
        //light.angle = 0.6; 
        //light.decay = 2;
        //light.penumbra = 0.2;          
        
        //light.shadow.camera.near = 1;
        //light.shadow.camera.far = 3;
        //light.shadow.camera.visible = true;            
        //light.shadow.mapSize.width = 1024;
        //light.shadow.mapSize.height = 1024;                                    
        //light.target = plane;
        scene.add(light);

        //scene.add (cc);
        // 告訴 renderer 我們需要陰影。
        renderer.shadowMap.enabled = true;

        //
        renderer.shadowMap.type = THREE.BasicShadowMap;

        // 定義哪個物體投射陰影。
        ctrl.castShadow = true;
        //ctrl.receiveShadow = true;

        // 定義哪個物體接受陰影。
        desk.receiveShadow = true;
    }
    
    function update(dt) {
        keyboard.update();
        if ( keyboard.pressed("left") ) 
            angle += 0.01;               
        if ( keyboard.pressed("right") )
            angle -= 0.01;               
        if ( keyboard.pressed("up") )  
            speed += 0.5;        
        if ( keyboard.pressed("down") )  
            speed -= 0.5;    
        speed = Math.clamp (speed, 0.1, 20.0);		
        vel = new THREE.Vector3(speed,0,0);
            
        vel.applyAxisAngle (new THREE.Vector3(0,1,0), angle);
        pos.add (vel.clone().multiplyScalar(dt)); 	
    }
    function animate() {
        controls.update();
        var dt = clock.getDelta();
        update(dt);
       
        renderer.render (scene, camera);
        requestAnimationFrame (animate);
    }
</script>
</body>
</html>