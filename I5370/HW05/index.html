<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=yes"/>
    <style type="text/css">@import"index.css";</style>
    <title>GI112 • HW05</title>
    <link rel="Shortcut Icon" type="image/x-icon" href="../icon.ico"/>
</head>

<body> 
            
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/88/three.min.js"></script>
<!--<script src="./three.js-master/examples/js/loaders/OBJLoader.js"></script>-->
<!--<script src="./three.js-master/examples/js/loaders/MTLLoader.js"></script>-->
<script src="https://rawgit.com/mrdoob/three.js/master/examples/js/loaders/MTLLoader.js"></script>
<script src="https://rawgit.com/mrdoob/three.js/master/examples/js/loaders/OBJLoader.js"></script>

<script src="https://threejs.org/examples/js/controls/OrbitControls.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/stats.js/r16/Stats.min.js"></script>
<script src="https://code.jquery.com/jquery-2.1.4.min.js"></script>

<script src="https://jyunming-chen.github.io/tutsplus/js/KeyboardState.js"></script>

<script>
    // renderer : 渲染器，負責計算在 camera 的角度下，browser 中 scene 的樣子。
    // scene : 場景，我們所看到的畫面。
    // camera : 定義了使用者能在渲染好的 scene 看到什麼，也就是使用者的視角。
    var renderer, camera, controls, scene, axes;
    var keyboard = new KeyboardState();
    var clock;
    
    var chair;
    var pos = new THREE.Vector3();
    var speed, angle, vel;
    (function() {
        Math.clamp = function(val,min,max){
        return Math.min(Math.max(val,min),max);
    }})();
    init();  // 創建渲染器
    animate();

    function buildDeskParts() {
        var parts = [];
        
        //var mat = new THREE.MeshNormalMaterial()
    	var mat = new THREE.MeshLambertMaterial({color:0x408080});

        // 桌面
        var desk = new THREE.Object3D();
        var deskMesh = new THREE.Mesh (new THREE.BoxGeometry (40, 80, 2),mat);  // 桌面

        deskMesh.rotation.x = Math.PI/2;
        deskMesh.position.y = 40;

        desk.add (deskMesh);
        parts.push (desk);

        // 桌腳 (共 4 支)
        var legs = new THREE.Object3D();
        var legsMesh_1 = new THREE.Mesh (new THREE.BoxGeometry (5, 5, 40),mat);  // 桌腳_1
        var legsMesh_2 = new THREE.Mesh (new THREE.BoxGeometry (5, 5, 40),mat);  // 桌腳_2
        var legsMesh_3 = new THREE.Mesh (new THREE.BoxGeometry (5, 5, 40),mat);  // 桌腳_3
        var legsMesh_4 = new THREE.Mesh (new THREE.BoxGeometry (5, 5, 40),mat);  // 桌腳_4

        legsMesh_1.rotation.x = Math.PI/2;
        legsMesh_1.position.x = -10;
        legsMesh_1.position.y = 20;
        legsMesh_1.position.z = 20;

        legsMesh_2.rotation.x = Math.PI/2;
        legsMesh_2.position.x = -10;
        legsMesh_2.position.y = 20;
        legsMesh_2.position.z = -20;

        legsMesh_3.rotation.x = Math.PI/2;
        legsMesh_3.position.x = 10;
        legsMesh_3.position.y = 20;
        legsMesh_3.position.z = 20;

        legsMesh_4.rotation.x = Math.PI/2;
        legsMesh_4.position.x = 10;
        legsMesh_4.position.y = 20;
        legsMesh_4.position.z = -20;

        legs.add (legsMesh_1);
        legs.add (legsMesh_2);
        legs.add (legsMesh_3);
        legs.add (legsMesh_4);

        parts.push (legs);

        return parts;
    }

    function buildDesk(){
        
        let parts = buildDeskParts();
        let desk = new THREE.Object3D();

        // 桌子。
        let deskPart = parts[0];
        let legsPart = parts[1];
        desk.add (deskPart);
        desk.add (legsPart);

        return desk;
    }

    function buildControlParts() {
        var parts = [];
        
        //var mat = new THREE.MeshNormalMaterial()
    	var mat = new THREE.MeshLambertMaterial({color:0xFFFFFF});

        // 遙控器
        var control = new THREE.Object3D();
        var controlMesh = new THREE.Mesh (new THREE.BoxGeometry (15, 10, 4),mat);  // 桌面

        controlMesh.rotation.x = Math.PI/2;
        controlMesh.position.y = 43;

        control.add (controlMesh);
        parts.push (control);

        // 按鈕_1 (共 2 個)
        var btns_1 = new THREE.Object3D();
        var btnsMesh_1 = new THREE.Mesh (new THREE.CylinderGeometry (2.5, 2.5, 2.5, 30), mat);  // 按鈕_1

        //btnsMesh.rotation.x = Math.PI/2;
        btnsMesh_1.position.x = 4;
        btnsMesh_1.position.y = 46.5;
        btnsMesh_1.position.z = 0;

        btns_1.add (btnsMesh_1);

        parts.push (btns_1);

        // 按鈕_2 (共 2 個)
        var btns_2 = new THREE.Object3D();
        var btnsMesh_2 = new THREE.Mesh (new THREE.CylinderGeometry (2.5, 2.5, 2.5, 30), mat);  // 按鈕_2

        //btnsMesh.rotation.x = Math.PI/2;
        btnsMesh_2.position.x = -4;
        btnsMesh_2.position.y = 46.5;
        btnsMesh_2.position.z = 0;

        btns_2.add (btnsMesh_2);

        parts.push (btns_2);

        return parts;
    }

    function buildControl(){
        
        let parts = buildControlParts();
        let ctrl = new THREE.Object3D();

        // 遙控器。
        let ctrlPart = parts[0];
        let btnsPart_1 = parts[1];
        let btnsPart_2 = parts[2];
        ctrl.add (ctrlPart);
        ctrl.add (btnsPart_1);
        ctrl.add (btnsPart_2);

        return ctrl;
    }

    function buildChair() {
        var onProgress = function (xhr) {
            if (xhr.lengthComputable) {
                var percentComplete = xhr.loaded / xhr.total * 100;
                console.log(Math.round(percentComplete, 2) + '% downloaded');
            }
        };

        var onError = function (xhr) { };
            
        var mtlLoader = new THREE.MTLLoader();
        mtlLoader.setPath('./chair/');
        mtlLoader.load('WoodChair_01.mtl', function(materials) {
            materials.preload();
            var objLoader = new THREE.OBJLoader();
            objLoader.setMaterials(materials);
            objLoader.setPath('./chair/');
            objLoader.load('WoodChair_01.obj', function(object) {
        
                theObject =  unitize (object, 50);

                theObject.rotation.x = - (Math.PI / 2);
                theObject.position.x = 30;
                theObject.position.y = 25;
                theObject.position.z = 13;
                scene.add (theObject);

                chair = theObject;
            }, onProgress, onError);
        });

    }

    function buildlamp() {
        var onProgress = function (xhr) {
            if (xhr.lengthComputable) {
                var percentComplete = xhr.loaded / xhr.total * 100;
                console.log(Math.round(percentComplete, 2) + '% downloaded');
            }
        };

        var onError = function (xhr) { };
            
        var mtlLoader = new THREE.MTLLoader();
        mtlLoader.setPath('./lamp/');
        mtlLoader.load('Desk lamp.mtl', function(materials) {
            materials.preload();
            var objLoader = new THREE.OBJLoader();
            objLoader.setMaterials(materials);
            objLoader.setPath('./lamp/');
            objLoader.load('Desk lamp.obj', function(object) {
        
                theObject =  unitize (object, 30);

                theObject.position.x = -10;
                theObject.position.y = 41;
                theObject.position.z = 20;
                theObject.rotation.y = 0.8;
                scene.add (theObject);

                //chair = theObject;
            }, onProgress, onError);
        });

    }

    function unitize (object, targetSize) {  
  
        // find bounding box of 'object'
        var box3 = new THREE.Box3();
        box3.setFromObject (object);
        var size = new THREE.Vector3();
        size.subVectors (box3.max, box3.min);
        var center = new THREE.Vector3();
        center.addVectors(box3.max, box3.min).multiplyScalar (0.5);
        
        // uniform scaling according to objSize
        var objSize = Math.max (size.x, size.y, size.z); 
        var scaleSet = targetSize/objSize;
        
        var theObject =  new THREE.Object3D();
        theObject.add (object);
        object.scale.set (scaleSet, scaleSet, scaleSet);
        object.position.set (-center.x*scaleSet, -center.y*scaleSet + size.y/2*scaleSet, -center.z*scaleSet);
        
        return theObject;
    }

    function buildlamplight(){
        var mat = new THREE.MeshBasicMaterial({color:0xFFFFFF, wireframe: true});
        let sunObj = new THREE.Object3D();
        sun = new THREE.Mesh (new THREE.SphereGeometry( 2, 32, 32 ),mat);
        sun.position.set (-7.5, 66, 17);
        sunObj.add (sun);
        return sunObj;
    }

    function init() {
        renderer = new THREE.WebGLRenderer({
            antialias: true
        });
        renderer.setSize(window.innerWidth, window.innerHeight - 10);
        renderer.setClearColor(0x84C1FF);  // 設定背景顏色
        camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 1, 1000);
        camera.position.z = 250;  // important
        camera.position.y = 150;
        //camera.position.x = 35;
        controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableKeys = false;
        document.body.appendChild(renderer.domElement);
        clock = new THREE.Clock();
        scene = new THREE.Scene();  // 建立場景
      
        // 設定座標網格。
        // THREE.GridHelper(面積, 長寬長度, xy軸顏色, 網格顏色);
        let gridXZ = new THREE.GridHelper(1000, 20, 'red', 'white');
        let planeObj = new THREE.Object3D();
        let planeGeometry = new THREE.PlaneGeometry( 1000, 1000, 1, 1 );
        var planeMaterial = new THREE.MeshBasicMaterial( { color: 0xFFFFFF } );
        var plane = new THREE.Mesh( planeGeometry, planeMaterial );
        plane.rotation.x = Math.PI / -2;
        plane.position.y = 0;
        planeObj.add(plane); 
        scene.add(gridXZ);
        scene.add(planeObj);
        let lamplight = buildlamplight();
        let ctrl = buildControl();

        //ctrl.position.y = 10;
        //ctrl.position.z = 10;

        buildChair();

        buildlamp();
        
        let desk = buildDesk();
        scene.add (desk);
        scene.add (ctrl);
        scene.add (lamplight);

        // 添加光源
        let light = new THREE.SpotLight( '#ffffff' ,1);
        light.castShadow = true;
        //light.distance = 50; 
        //light.angle = 0.6; 
        //light.decay = 2;
        //light.penumbra = 0.2;          
        light.position.set( -7.5, 1066, 17 );
        //light.shadow.camera.near = 1;
        //light.shadow.camera.far = 3;
        //light.shadow.camera.visible = true;            
        //light.shadow.mapSize.width = 1024;
        //light.shadow.mapSize.height = 1024;                                    
        light.target = plane;
        scene.add(light);

        //scene.add (cc);
        // 告訴 renderer 我們需要陰影。
        renderer.shadowMapEnabled = true;

        // 定義哪個物體投射陰影。
        ctrl.castShadow = true;

        // 定義哪個物體接受陰影。
        desk.receiveShadow = true;
    }
    
    function update(dt) {
        keyboard.update();
        if ( keyboard.pressed("left") ) 
            angle += 0.01;               
        if ( keyboard.pressed("right") )
            angle -= 0.01;               
        if ( keyboard.pressed("up") )  
            speed += 0.5;        
        if ( keyboard.pressed("down") )  
            speed -= 0.5;    
        speed = Math.clamp (speed, 0.1, 20.0);		
        vel = new THREE.Vector3(speed,0,0);
            
        vel.applyAxisAngle (new THREE.Vector3(0,1,0), angle);
        pos.add (vel.clone().multiplyScalar(dt)); 	
    }
    function animate() {
        controls.update();
        var dt = clock.getDelta();
        update(dt);
       
        renderer.render (scene, camera);
        requestAnimationFrame (animate);
    }
</script>
</body>
</html>